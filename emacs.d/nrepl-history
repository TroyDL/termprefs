;; -*- coding: utf-8-unix -*-
;; Automatically written history of nREPL session
;; Edit at your own risk

("(util/find-keypaths {} {0 1})" "(map #(get-in {:a {:b {:c 0} :d 1} :e 2 :f {:c 0}} %) '([:a :b :c] [:f :c]))" "(get-in {:a {:b {:c 0} :d 1} :e 2 :f {:c 0}} (first ([:a :b :c] [:f :c])))" "(get-in {:a {:b {:c 0} :d 1} :e 2 :f {:c 0}} [:a :b :c])" "(map #(get-in {:a {:b {:c 0} :d 1} :e 2 :f {:c 0}} %) ([:a :b :c] [:f :c]))" "(util/find-in-flat-map {:a {:b {:c 0} :d 1} :e 2 :f {:c 0}} {:c 0})" "(util/find-in-flat-map {:a {:b {:c 0} :d 1} :e 2} {:c 0})" "(map #(= 0 %) (vals (util/flatten-map {:a {:b {:c 0} :d 1} :e 2})))" "(= 0 0)" "(some true? (map (fn [ks] (some #(= :c %) ks)) (keys (util/flatten-map {:a {:b {:c 0} :d 1} :e 2}))))" "(map (fn [vs] (some #(= 0 %) vs)) (vals {[:a :b :c] 0, [:a :d] 1, [:e] 2}))" "(some true? (map (fn [vs] (some #(= 0 %) vs)) (vals {[:a :b :c] 0, [:a :d] 1, [:e] 2})))" "(util/find-in-flat-map {:a {:b {:c 0} :d 1} :e 2} {:c 0})" "(first {:a 0})" "(keys (util/flatten-map {:a {:b {:c 0} :d 1} :e 2}))" "(vals (util/flatten-map {:a {:b {:c 0} :d 1} :e 2}))" "(util/flatten-map {:a {:b {:c 0} :d 1} :e 2})" "(util/find-in-flat-map {:a {:b {:c 0} :d 1} :e 2} [:c 0])" "(util/find-in-flat-map {:a {:b {:c 0} :d 1} :e 2} {:c 0})" "(util/find-in-flat-map {:a {:b {:c 0} :d 1} :e 2} :c 0)" "(flatten {:a 0})" "(flatten (seq {:a {:b {:c 0} :d 1} :e 2}))" "(some true? (map (fn [ks] (some #(= :c %) ks)) (keys (util/flatten-map {:a {:b {:c 0} :d 1} :e 2}))))" "(some true? '(true nil nil))" "(some true? (true nil nil))" "(some true? *1)" "(map (fn [ks] (some #(= :c %) ks)) (keys (util/flatten-map {:a {:b {:c 0} :d 1} :e 2})))" "(some true? *1)" "(map (fn [ks] (some #(= :c %) ks)) (keys (util/flatten-map {:a {:b {:c 0} :d 1} :e 2})))" "(some #(= :c %) [:a :b :c])" "(contains? [:a :b :c] :c)" "(map #(contains? % :c) (keys (util/flatten-map {:a {:b {:c 0} :d 1} :e 2})))" "(contains? {:a {:b 0} :c 9} :b)" "(contains? {:a {:b 0} :c 9} :c)" "(vals {:a {:b 0} :c 9})" "(map #(get-in m %) (keys fm))" "(seq fm)" "fm" "(def fm (flatten-map m))" "(def m {:a {:b {:c 0} :d 1} :e 2})" "(flatten-map {\"blah\" \"Woo\" :a {[113 42] \"wonk\"}})" "(flatten-map {\"blah\" \"Woo\"})" "(flatten-map {})" "(require '[map-tools.core :refer :all])" "(core/flatten-map {})" "(flatten-map {})" "flkfj" "(util/flatten-map {:a {:b {:c 0} :d 1} :e 2})" "(time (dotimes [n 100000] (util/flatten-map test-map)))" "(conj {:a 1} {[:a :b] 3})" "(conj {} {:a 1})" "(time (dotimes [n 100000] (util/flatten-map test-map)))" "(time (dotimes [n 100000] (util/proto-flatten-map test-map)))" "(time (dotimes [n 100000] (util/flatten-map test-map)))" "(time (dotimes [n 1000000] (util/flatten-map test-map)))" "(time (dotimes [n 10000] (util/flatten-map test-map)))" "(time (dotimes [n 100] (util/flatten-map test-map)))" "(time (util/flatten-map test-map))" "(def test-map {:a {:a1 0 :a1.1 {:a2 1 :a2.2 {:a3 2} :a2.3 3} :a1.2 4} :b {:b1 5}
                        :z 9 :x 8 :y 7 :t 4})" "(util/flatten-map {})" "(util/flatten-map {:a {:b 2} :c {:d {:e 3}}})" "(util/flatten-map {:a {:b 2}})" "(util/flatten-map {:a 1})" "(util/flatten-map {})" "(flatten-map {})" "(flatten-map {:a 1})" "(flatten-map {:a 1 :b 2})" "
     (flatten-map {:a {:b {:c 0} :d 1} :e 2})" "(util/flatten-map {})" "(util/flatten-map {:a 0})" "(util/flatten-map {})" "[ 1 2 3 4 5 6 7 8 9 ]" "(util/proto-flatten-map {})" "(util/flatten-map {})" "(util/flatten-map {:a 1})" "(util/flatten-map {})" "(let [[k v] (first {:a 1 :b 2})
            cm {k v}] cm)" "(let [[k v] (first {:a 1 :b 2})] {k v})" "(let [[k v] (first {:a 1 :b 2})] v)" "(let [[k v] (first {:a 1 :b 2})] k)" "(let [[k v] (first {:a 1 :b 2})])" "(hash-map (first {:a 1 :b 2}))" "(hash-map (drop 1 {:a 1 :b 2}))" "(drop 1 {:a 1 :b 2})" "(first {:a 1 :b 2})" "(util/flatten-map {:a 1 :b 2 \"c\" 3 4 4 :d {:d1 5} :e \"6\" :f {:f1 {:f2 {:f3 [1 2]}}}})" "(util/flatten-map {:a 1 :b 2 \"c\" 3 4 4 :d {:d1 5} :e \"6\" :f {:f1 {:f2 {:f3 7}}}})" "(util/flatten-map {:a {:b {:c 0} :d 1} :e 2})" "(util/flatten-map {:a 1 :b 2 \"c\" 3 4 4 :d {:d1 5} :e \"6\" :f {:f1 {:f2 {:f3 7}}}})" "(util/flatten-map {:a {:b {:c 0}}})" "(util/flatten-map {:a 1 :b 2 \"c\" 3 4 4 :d {:d1 5} :e \"6\" :f {:f1 7}})" "(util/flatten-map {:a 1 :b 2 \"c\" 3 4 4 :d {:d1 5} :e \"6\" :f {:f1 7}}})" "(util/flatten-map {:a 1 :b 2 \"c\" 3 4 4 :d {:d1 5} :e \"6\" :f {:f1 {:f2 7}}})" "(util/flatten-map {:a 1 :b 2 \"c\" 3 4 4 :d {:d1 5} :e \"6\" :f {:f1 {:f2 {:f3 7}}}})" "(util/flatten-map {:a 1 :b 2 \"c\" 3 4 4 :d {:d1 5} :e \"6\" })" "(util/flatten-map {:a 1 :b 2 \"c\" 3 4 4 :d {:d1 5} :e \"6\" :f {\"f1\" {2 {:f3 7}}}})" "(util/flatten-map {:a 1 :b 2 \"c\" 3 4 4 :d {:d1 5}})" "(util/flatten-map {:a 1 :b 2 \"c\" 3 4 4})" "(util/flatten-map {:a 1 :b 2 \"c\" 3})" "(util/flatten-map {:a 1 :b 2})" "(util/flatten-map {:a 1})" "(util/flatten-map {})" "(hash-map [:a :b] 2)" "(util/flatten-map {\"a\" 1 :b 2 :c {:c1 3} :d {:d1 4 :d2 {\"b\" {:d4 5} 5 6}}})" "(conj [:a] :b)" "{[:a :b] 2}" "(util/flatten-map {\"a\" 1 :b 2 :c {:c1 3} :d {:d1 4 :d2 {\"b\" {:d4 5} 5 6}}})" "{a 1}" "(util/flatten-map {\"a\" 1 :b 2 :c {:c1 3} :d {:d1 4 :d2 {\"b\" {:d4 5} 5 6}}})" "(util/flatten-map {\"a\" 1 :b 2 :c {:c1 3} :d {:d1 4 :d2 {\"b\" {:d4 5} :d5 6}}})" "(util/flatten-map {\"a\" 1 :b 2 :c {:c1 3} :d {:d1 4 :d2 { {:d4 5} :d5 6}}})" "(util/flatten-map {\"a\" 1 :b 2 :c {:c1 3} :d {:d1 4 :d2 {:d3 {:d4 5} :d5 6}}})" "(util/flatten-map {:a 1 :b 2 :c {:c1 3} :d {:d1 4 :d2 {:d3 {:d4 5} :d5 6}}})" "(util/flatten-map {:a 1 :b 2 :c {:c1 3}})" "(util/flatten-map {:a 1 :b 2})" "(util/flatten-map {:a 1})" "(util/pull {:a 1})" "(first {:a 1})" "(util/pull '(:a 1))" "(util/pull {})" "(util/pull {:a 1})" "(def atom1 (atom {}))" "@atom1" "(deref atom1)" "(eval atom1)" "atom1" "(def atom1 (atom {}))" "(util/pull {:a 1})" "(util/pull {})" "(doseq [key (keys {:a 1})] (println ({:a 1} key)))" "({:a 1} (keys {:a 1}))" "(keys {:a 1})" "(util/pull {:a 1})" "(when {} \"yes\")" "(util/pull {})" "(util/pull-kvs {:a 1 :b 2 :c {:c2 3}})" "(util/pull-kvs {:a 1 :b 2 {:c 3}})" "(util/pull-kvs {:a 1 :b 2})" "(util/pull-kvs {:a 1})" "(seq {:a 1 :b 2})" "(seq {:a 1})" "(util/pull-kvs {:a 1})" "(first *1)" "(first {:a 1})" "(util/pull-kvs {:a 1})" "(util/pull-kvs {})" "m1" "(first {:a 1 :b 2})" "(map? (first (seq {:a 1 :b 2})))" "(seq {:a 1 :b 2})" "(reduce into {} (map pull-maps (pull-maps m1)))" "(pp)" "(reduce into {} (pull-maps m1))" "(map (comp pull-maps first) (map pull-maps (pull-maps m1)))" "(map pull-maps (map pull-maps (pull-maps m1)))" "(pp)" "(map pull-maps (pull-maps m1))" "(pull-maps m1)" "(pp)" "(map pull-maps maps)" "(apply pull-maps maps)" "(reduce pull-maps () maps)" "(reduce pull-maps maps)" "maps" "(pp)" "(map pull-maps maps)" "(-> m1
          pull-maps
          println
          pull-maps
          println)" "(pull-maps m1)" "(defn pull-maps [m1]
        (->> m1
             keys
             (map m1)
             (filter map?)))" "(->> m1
           keys
           (map m1)
           (filter map?))" "(->> m1
           keys
           map
           (filter map?))" "(map? (first (filter map? (map m1 (keys m1)))))" "(map? (filter map? (map m1 (keys m1))))" "(filter map? (map m1 (keys m1)))" "(count m1)" "m1" "(def m1 {:a 1 :b {:c 2} :d {:e {:f 3}} :g {:h 4 :i {:j {:k 5} :l 6}}})" "(filter map? (map (first maps) (keys (first maps))))" "(util/s1 {:c {:d 2}, :e 3} :e 2)" "(util/s1 {:c {:d 2}, :e 3} :e 3)" "(util/s1 {:c {:d 2}, :e 3} :d 2)" "(util/s1 {:c {:d 2}, :e 3} :e 3)" "(util/s1 *1 :e 3)" "(filter map? (map (first maps) (keys (first maps))))" "(filter map? (map (first map1) (keys (first map1))))" "(map (first maps) (keys (first maps)))" "(util/s1 (first maps) :f 1)" "(util/s1 (first maps) :a 1)" "(filter map? (map (first maps) (keys (first maps))))" "(map (first maps) (keys (first maps)))" "(util/s1 (first maps) :z 1)" "(keys (first maps))" "(util/s1 (first maps) :z 1)" "(first maps)" "(util/s1 (first maps) :z 1)" "(for [map (first maps)] (println map))" "(doseq [map (first maps)] (println map))" "(doseq [map maps] (println map))" "(for [map maps] (println map))" "(util/s1 (first maps) :d 2)" "(util/s1 (first maps) :f 4)" "(util/s1 (first maps) :e 3)" "(util/s1 (first maps) :a 1)" "(util/s1 (first maps) [:b :c :d] 3)" "(util/s1 (first maps) [:b :c :d] 2)" "(util/s1 (first maps) [:b :c] {:d 2})" "(util/s1 (first maps) [:b :c] {:d 3})" "(util/s1 (first maps) [:b :c] {:d 2})" "(util/s1 (first maps) [:b] {:c {:d 2}, :e 3})" "(get-in (first maps) [:b])" "(util/s1 (first maps) [:b] '{:c {:d 2}})" "(util/s1 (first maps) [:b] {:c {:d 2}})" "(util/s1 (first maps) [:a] 1)" "(util/s1 (first maps) :a 1)" "(util/s1 (first maps) [:a 1])" "maps" "(vec [:a :b])" "(util/sift! maps {:e 3})" "(vec (list :a))" "(vec :a)" "(util/sift! maps {:e 3})" "(pp)" "maps" "(util/sift! maps {:f 4})" "(util/sift! maps {:d 2})" "(util/sift! maps {:a 1})" "(util/sift! maps '([:a 1]))" "(util/sift! maps '(:a 1))" "(seq {:a 1 :b 2})" "(seq '(:a 1 :b 2))" "(seq '(:a 1))" "(util/sift! maps '(:a 1))" "(pp)" "(util/sift! maps '([:a 1]))" "(pp)" "(util/sift! maps '([:a 1]))" "(pp)" "(util/sift! maps '([:a 1]))" "(util/sift! maps '([:a 1]))a" "(pp)" "(util/sift! maps '([:a 1]))" "(pp)" "(util/sift! maps '([:a 1]))" "(count maps)" "(util/sift! maps '([:a 1]))" "(pprint maps)" "(pp)" "maps" "(util/sift! maps '([:a 1]))" "(list :a)" "(seq (keyword :a))" "(seq :a)" "(util/sssift (first maps) [:a 1])" "(seq '([:a 1][:b 2]))" "(seq '([:a 1]))" "(seq ([:a 1]))" "(seq [:a 1])" "(first maps)" "(util/sift! maps '([:a 1]))" "(type util/sift!)" "(util/sift! maps '([:a 1]))" "(util/sift! maps [[:a 1]])" "(util/sift! maps [:a 1])" "(util/sift! maps '(:a 1))" "(= *1 maps)" "(util/sift! maps '())" "(util/sift! maps '(:a 1))" "(util/sift! maps [:a 1])" "(util/sssift (first maps) {:a 1})" "(util/sift! maps {:a 1})" "(def maps '({:a 1 :b {:c {:d 2} :e 3} :f 4} {:a 2 :b {:c {:d 3} :e 4} :f 5} 
                  {:a 6 :b {:c {:d 2} :e 4} :f 5} {:a 1 :b {:c {:d 4} :e 5} :f 6}
                  {:a 1 :g {:c {:d 2} :e 3} :f 4} {:a 1} {:a 2})) " "(get-in {:a 1 :b {:c 2}} '(:a))" "(get-in {:a 1 :b {:c 2}} :a)" "(util/sssift {:a 1 :b {:c 2 :d {:e 3}}} [:a] 3)" "(util/sssift {:a 1 :b {:c 2 :d {:e 3}}} [:a] 1)" "(util/sssift {:a 1 :b {:c 2 :d {:e 3}}} [:a] 2)" "(util/sssift {:a 1 :b {:c 2 :d {:e 3}}} [:a] 1)" "(util/sssift {:a 1 :b {:c 2 :d {:e 3}}} [:a :c] 2)" "(util/sssift {:a 1 :b {:c 2 :d {:e 3}}} [:b :c] 2)" "(util/sssift {:a 1 :b {:c 2 :d {:e 3}}} [:a :c] 2)" "(util/sssift {:a 1 :b {:c 2 :d {:e 3}}} [:a] 2)" "(util/sssift {:a 1 :b {:c 2 :d {:e 3}}} [:a] 12)" "(util/sssift {:a 1 :b {:c 2 :d {:e 3}}} [:a] 10)" "(util/sssift {:a 1 :b {:c 2 :d {:e 3}}} [:a] 1)" "(get-in {:a {:b 2}} '(:a :b))" "(vec '(:a :b))" "(vec [\"blah\" \"meh\"])" "(first '(\"blah\"))" "(eval '(\"blah\"))" "(conj '(:a :b) :c)" "(cons '(:a :b) :c)" "(cons (seq [:a :b]) :c)" "(assoc [:a :b] 0 :c)" "(cons [:a :b] :c)" "(conj [:a :b] :c)" "(get [:k 1] :k)" "(:k [:k 1])" "(filter map? (map {:k 1 :k2 2 :k3 {:k4 4}} (keys {:k 1 :k2 2 :k3 {:k4 4}})))" "(filter map? keys1)" "(def keys1 (map {:k 1 :k2 2 :k3 {:k4 4}} (keys {:k 1 :k2 2 :k3 {:k4 4}})))" "(map {:k 1 :k2 2 :k3 {:k4 4}} (keys {:k 1 :k2 2 :k3 {:k4 4}}))" "(keys {:k 1 :k2 2 :k3 {:k4 4}})" "(map {:k 1 :k2 2 :k3 {:k4 4}} '(:k :k2 :k3))" "(map {:k 1 :k2 2 :k3 {:k4 4}} (keys {:k 1 :k2 2 :k3 {:k4 4}}))" "(map {:k 1 :k2 2 :k3 {:k4 4}} (reverse (keys {:k 1 :k2 2 :k3 {:k4 4}})))" "(map {:k 1 :k2 2 :k3 {:k4 4}} (keys {:k 1 :k2 2 :k3 {:k4 4}}))" "(util/sssift {:k 1 :k2 2} {:k 3})" "(util/sssift {:k 1 :k2 2} {:k 1})" "(util/sssift {:k 1 :k2 2} {:k1 1})" "(util/sssift {:k 1 :k2 2} {:k2 2})" "(util/sssift {:k 1 :k2 2} {:k2 1})" "(util/sssift {:k 1 :k2 2} {:k3 1})" "(ffirst {:a 1})" "(first {:a 1})" "(util/sssift {:k 1 :k2 2} {:k3 1})" "(util/sssift {:k 1 :k2 2} {:k 1})" "(util/sssift {:k 1} {:k 1})" "(util/sssift maps1 {:a \"a\"})" "(util/ssift maps1 {:a \"a\"})" "(util/ssift maps1 [:a \"a\"])" "(def maps1 '({:a \"a\" :b \"b\"} {:a \"a\" :b \"2b\"} {:a \"a\" :b \"3b\"} {:a \"aa\" :b \"4b\"}))" "m1" "(let [{key val} [:k1 \"a\"]] key)" "(seq {:k1 \"a\" :k2 \"b\" :k3 \"c\" :k4 \"d\"})" "(partition 2 (seq {:k1 \"a\" :k2 \"b\" :k3 \"c\" :k4 \"d\"}))" "(partition 2 {:k1 \"a\" :k2 \"b\" :k3 \"c\"})" "(partition 2 {:k1 \"a\" :k2 \"b\" :k3 \"c\" :k4 \"d\"})" "(partition 2 {:k1 \"a\" :k2 \"b\" :k3 \"c\"})" "(partition 2 {:k1 'a :k2 'b :k3 'c})" "(partition 2 {:k1 'a :k2 'b :k3 {:k4 'c}})" "(partition 2 {:k1 'a :k2 'b})" "\"First check if (= (get [coll] :key) 'val'), if not try (get-in coll [% %]) where the
first iterates through the top level keys of the coll and the second is the final key\" " "\"First check if (= (get [coll] :key) \"val\"), if not try (get-in coll [% %]) where the
first iterates through the top level keys of the coll and the second is the final key\" " "(map #(get % %) (list (keys m1)) [:k3])" "(map #(get % %) (keys m1) [:k3])" "(keys m1)" "(map #(get % %1) (keys m1) [:k3])" "(map #(get m1 %) [:k3])" "(= (:k2 m1) (:k2 target1))" "(def target1 {:k2 {:k3 \":k2 :k3\"}})" "(:k2 target1)" "(:k2 m1)" "target1" "m1" "(= (:k2 m1) (:k2 target1))" "(def target1 {:k2 {:k3 \":2 :k3\"}})" "(def m1 {:k1 \"k1\" :k2 {:k3 \":k2 :k3\"}})" "(keys {:k1 1 :k2 {:k3 2}})" "(get-in {:k1 1 :k2 {:k3 2}} [:k2 :k3])" "(get-in {:k1 1 :k2 {:k3 2}} [:k3 :k2])" "(get-in {:k1 1 :k2 {:k3 2}} [:k2 :k3])" "(get-in {:k1 1 :k2 {:k3 2}} [:k1 :k2])" "(get-in {:k1 1 :k2 {:k3 2}} '[k1])" "(get-in {:k1 1 :k2 {:k3 2}} [k1])" "(get-in {:k1 1 :k2 {:k3 2}} [:k1])" "(flatten {:k1 1 :k2 {:k3 2}})" "(contains? {:k1 1 :k2 {:k3 2}} {:k2 {:k3 2}})" "(contains? {:k1 1 :k2 {:k3 2}} :k3)" "(contains? {:k1 1 :k2 {:k3 2}} :k2)" "(contains? {:k1 1 :k2 {:k3 2}} :k1)" "(contains? [{:k1 1 :k2 {:k3 2}}] :k1)" "(contains? [{:k1 1 :k2 {:k3 2}}] :k1))" "(contains? [{:k1 1 :k2 {:k3 2}}] :k3)" "(contains? [{:k1 1 :k2 {:k3 2}}] {:k2 {:k3 2}})" "(util/distinct-on '({:k1 1 :k2 2} {:k1 11 :k2 22} {:k2 222} {:k2 223}) [:k1])" "(contains? #{nil} (get-in {:a 2} [:b]))" "(util/distinct-on '({:k1 1 :k2 2} {:k1 11 :k2 22} {:k2 222} {:k2 223}) [:k1])" "(util/distinct-on '({:k1 1 :k2 2} {:k1 11 :k2 22} {:k2 222} {:k2 223}))" "(= 
  ({:k1 \"v1\", :k2 {:k3* \"v2*\"}} {:k1 \"v3\", :k2 {:k2* \"v4*\"}} {:k1 \"v1\", :k2 {:k2* \"v2*\"}}) 
  ({:k1 \"v1\", :k2 {:k3* \"v2*\"}} {:k1 \"v3\", :k2 {:k2* \"v4*\"}} {:k1 \"v1\", :k3 {:k2* \"v4\"}}))" "(= ({:k1 \"v1\", :k2 {:k3* \"v2*\"}} {:k1 \"v3\", :k2 {:k2* \"v4*\"}} {:k1 \"v1\", :k2 {:k2* \"v2*\"}}) ({:k1 \"v1\", :k2 {:k3* \"v2*\"}} {:k1 \"v3\", :k2 {:k2* \"v4*\"}} {:k1 \"v1\", :k3 {:k2* \"v4\"}}))" "
      " "'({:id 30497, :data {:test_node \"n3\", :data 656782.4839751186}})" "'({:id 30497, :data 656782.4839751186, :test_node \"n3\"})" "'(sojourn travel journey return distinct-on strain sift)" "(run-all-tests)" "(pp)" "(util/trim-ress cyt4)" "
(def cyt4 ;;responses for tests
      (cy/query \"start n=node(*), n2=node(*) where not(n=n2) return n, n2 limit 30\"))" "(pp)" "(util/trim-ress cyt4)" "(trim-ress cyt4)" "(pp)" "(util/trim-ress cyt5)" "
(def cyt5 ;;responses for tests
      (cy/query \"start n=node(*), n2=node(*), n3=node(*)
       where not(n=n2) and not(n2=n3) and not(n=n3) return n, n2, n3 limit 30\"))" "(pp)" "(util/trim-ress cyt5)" "
(def cyt5 ;;responses for tests
      (cy/query \"start n=node(*), n2=node(*), n3=node(*)
       where not(n=n2) and not(n2=n3) and not(n=n3) return n, n2, n3 limit 18\"))" "(pp)" "(util/trim-ress cyt5)" "(pp)" "(util/trim-ress cyt6)" "(util/trim-ress cyt6)a" "
(def cyt6 ;;responses for tests
      (cy/query \"start n=node(*) match (n)-[]-(n2) return n, n2 limit 8\"))" "(util/trim-ress cyt6)" "(pp)" "(map util/trim-ress [cyt1 cyt2 cyt3 cyt4 cyt5 cyt6])" "
(def cyt1 ;;responses for tests
      (cy/query \"start n=node(*) return n limit 1\"))
(def cyt2 ;;responses for tests
      (cy/query \"start n=node(*) return n limit 5\"))
(def cyt3 ;;responses for tests
      (cy/query \"start n=node(*) return n limit 25\"))
(def cyt4 ;;responses for tests
      (cy/query \"start n=node(*), n2=node(*) where not(n=n2) return n, n2 limit 5\"))
(def cyt5 ;;responses for tests
      (cy/query \"start n=node(*), n2=node(*), n3=node(*)
       where not(n=n2) and not(n2=n3) and not(n=n3) return n, n2, n3 limit 9\"))
(def cyt6 ;;responses for tests
      (cy/query \"start n=node(*) match (n)-[]-(n2) return n limit 8\"))
" "(in-ns graphlete.data.util (+ 1 1))" "util/cyt5" "(cy/query \"start n=node(*), n2=node(*), n3=node(*)
       where not(n=n2) and not(n2=n3) and not(n1=n3) return n, n2, n3 limit 9\")" "\"make various cy queries to test trim-ress with\"" "(require '[graphlete.data.query :as q])" "(q/start )" "(util/trim-ress cyq)" "(trim-ress cyq)" "(count (reduce into () (-> cyq :data)))" "(count (reduce into '() (-> cyq :data)))" "(reduce into '() (-> cyq :data)) " "(reduce #(into () %) (-> cyq :data)) " "\"Turn it into a list of hashmaps\"" "\"vector of vectors of hashmaps\"" "cyq" "\"I have a vector of hashmaps\"" "(count (map first (-> cyq :data)))" "(map first (-> cyq :data))" "(count (-> cyq :data))" "(map (comp :data first) (-> cyq :data))" "(-> cyq :data first)" "(map :data (-> cyq :data))" "(pp)" "(-> cyq, :data)" "(-> cyq, :data, first)" "(def cyq (cy/query \"start n=node(*), n2=node(*) where not(n=n2) return n, n2 limit 4\"))" "(util/trim-res *2)" "(pp)" "(cy/query \"start n=node(*), n2=node(*) where not(n=n2) return n, n2 limit 4\")" "(cy/query \"start n=node(*), n2=node(*) where n!=n2 return n, n2 limit 4\")" "(second (second cyq))" "(:columns (second cyq))" "(second cyq)" "(type (ffirst normal-cyq))" "(type (ffirst cyq))" "(type (first normal-cyq))" "(type (first cyq))" "(type cyq)" "normal-cyq" "(count (:data normal-cyq))" "(def normal-cyq (cy/query \"start n=node(*) return n limit 4\"))" "(dev normal-cyq (cy/query \"start n=node(*) return n limit 4\"))" "(count (first (:data cyq)))" "(type (first (:data cyq)))" "(type (:data cyq))" "(count (:data cyq))" "(count (ffirst cyq))" "(def cyq (cy/query \"start n=node(2), n2=node(3), n3=node(4) return n, n2, n3\"))" "(pp)" "(cy/query \"start n=node(2), n2=node(3) return n, n2\")" "(count (second (second cyq)))" "(second (second cyq))" "(ssecond cyq)" "(second cyq)" "(util/trim-res (cy/query \"start n=node(2) match (n)-[:HAS_STAT_TYPE]-(n2)
   return n2, n\"))" "(util/trim-res (cy/query \"start n=node(2) match (n)-[:HAS_STAT_TYPE]-(n2)
   return n, n2\"))" "(util/trim-res (cy/query \"start n=node(2), n2=node(3) return n, n2\"))" "(pp)" "(cy/query \"start n=node(2), n2=node(3) return n, n2\")" "(util/trim-res (cy/query \"start n=node(2), n2=node(3) return n, n2\"))" "(util/trim-res cyq)" "(pp)" "cyq" "(def cyq (cy/query \"start n=node(*) match (n)-[:PLAYS]-(n2)-[:REPRESENTS]-(n3) return n, n2, n3 limit 3\"))" "cyq" "(util/trim-res cyq)" "(take 2 cyq)" "(take 20 (util/trim-res cyq))" "(def cyq (cy/query \"start n=node(*) match (n)-[:PLAYS]-(n2)-[:REPRESENTS]-(n3) return n, n2, n3\"))" "(pp)" "(util/trim-res cyq)" "(pp)" "(util/trim-res cyq)" "(util/trim-res scyq)" "scyq" "(def scyq (cy/query \"start n=node(2) return n\"))" "(count cyq)" "(def cyq (cy/query \"start n=node(*) match (n)-[:HAS_POSITION]-(n2) return n, n2\"))" "(take 5 (util/return players [:id]))" "(count (util/distinct-on players [:first_name]))" "(count (distinct-on players [:last_name]))" "(count players)" "(count (util/strain players [:slug]))" "(take 5 (util/strain players [:slug]))" "(util/strain players [:slug])" "(util/sift players {:last_name \"Mendez\"})" "(count players)" "(def players (util/travel 2 [:PLAYS :REPRESENTS :ATTENDS]))" "(def players (u/travel 2 [:PLAYS :REPRESENTS :ATTENDS]))" "(take 2 (u/travel 30218 [:PLAYS_FOR :PLAYS_FOR]))" "(take 2 (u/journey 30218 [:PLAYS_FOR :PLAYS_FOR]))" "(take 2 (u/sojourn 30218 [:PLAYS_FOR :PLAYS_FOR]))" "(take 222 (u/travel 30218 [:PLAYS_FOR :PLAYS_FOR]))" "(take 222 (u/journey 30218 [:PLAYS_FOR :PLAYS_FOR]))" "(pp)" "(take 222 (u/sojourn 30218 [:PLAYS_FOR :PLAYS_FOR]))" "(take 5 (u/sojourn 30218 [:PLAYS_FOR :PLAYS_FOR]))" "(take 5 (u/sojourn 30218 [:PLAYS_FOR]))" "(take 2 (u/sojourn 2 [:PLAYS :REPRESENTS :ATTENDS]))" "(u/travel 2 [])" "(u/journey 2 [])" "(u/sojourn 2 [])" "(require '[graphlete.data.util :as u])")